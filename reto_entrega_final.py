# -*- coding: utf-8 -*-
"""RETO_Entrega_FINAL.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_A8RROB66kkwv7Yot6Wx5_Qz9pufEAk5
"""

pip install agentpy

import agentpy as ap
import numpy as np
import json
from IPython.display import HTML, display
from matplotlib import pyplot as plt
import matplotlib.animation as anim_module
import heapq

# Message class for agent communication
class Message:
    def __init__(self, key, content):
        self.key = key
        self.content = content

class TrafficLightGroup(ap.Agent):
    def __init__(self, model, group_name, positions, initial_state_index=0, **kwargs):
        super().__init__(model, **kwargs)
        self.group_name = group_name
        self.positions = positions  # List of positions controlled by this group
        self.state_cycle = ['red', 'yellow', 'green', 'yellow']
        self.state_durations = [15, 5, 15, 5]  # Durations for each state
        self.current_state_index = initial_state_index % len(self.state_cycle)
        self.time_in_state = 0
        self.current_state = self.state_cycle[self.current_state_index]
        print(f"Traffic light group '{self.group_name}' initialized with state '{self.current_state}'")

    def step(self):
        """Update the traffic light state based on the time in the current state."""
        self.time_in_state += 1
        if self.time_in_state >= self.state_durations[self.current_state_index]:
            self.current_state_index = (self.current_state_index + 1) % len(self.state_cycle)
            self.current_state = self.state_cycle[self.current_state_index]
            self.time_in_state = 0  # Reset time in state
        print(f"Traffic light group '{self.group_name}' - State: {self.current_state}, Time in State: {self.time_in_state}")

class Environment:
    def __init__(self, grid):
        self.grid = grid
        self.height = len(grid)
        self.width = len(grid[0]) if grid else 0

        # Road, sidewalk, crosswalks, and obstacles values
        self.road = [(i, j) for i in range(self.height) for j in range(self.width) if grid[i][j] == 0]
        self.sidewalks = [(i, j) for i in range(self.height) for j in range(self.width) if grid[i][j] == 1]
        self.crosswalks = [(i, j) for i in range(self.height) for j in range(self.width) if grid[i][j] == 2]
        self.obstacles = [(i, j) for i in range(self.height) for j in range(self.width) if grid[i][j] == 3]

    def valid_position(self, pos):
        return 0 <= pos[0] < self.height and 0 <= pos[1] < self.width

    def is_obstacle(self, pos, agent_type, dynamic_obstacles=None):
        """
        Determine if a position is an obstacle for a given agent type.
        """
        if not self.valid_position(pos):
            return True  # Out of bounds is considered an obstacle
        if dynamic_obstacles and pos in dynamic_obstacles:
            return True  # Dynamic obstacle (another agent)
        terrain = self.grid[pos[0]][pos[1]]
        if terrain == 3:
            return True  # Obstacle
        elif agent_type == 'car':
            if terrain == 1:
                return True  # Sidewalks block drivers
        return False

    def traversal_cost(self, pos, agent_type):
        if not self.valid_position(pos):
            return float('inf')
        terrain = self.grid[pos[0]][pos[1]]
        if terrain == 3:
            return float('inf')  # Obstacle
        if agent_type == 'pedestrian':
            if terrain == 1:
                return 1  # Sidewalk cost
            elif terrain == 2:
                return 1  # Crosswalk cost
            elif terrain == 0:
                return 10  # Road cost
            else:
                return float('inf')
        elif agent_type == 'car':
            if terrain == 0:
                return 1  # Road cost
            elif terrain == 2:
                return 5  # Crosswalk cost, higher for cars
            else:
                return float('inf')
        else:
            return float('inf')

    def is_crosswalk(self, pos):
        return pos in self.crosswalks

    def assign_traffic_lights_to_crosswalks(self, horizontal_traffic_light, vertical_traffic_light):
        self.crosswalk_to_traffic_light = {}
        for pos in self.crosswalks:
            i, j = pos
            # Assign crosswalks based on proximity to traffic lights
            if i in [9, 10]:  # Rows controlled by the vertical light
                self.crosswalk_to_traffic_light[pos] = vertical_traffic_light
            elif j in [9, 10]:  # Columns controlled by the horizontal light
                self.crosswalk_to_traffic_light[pos] = horizontal_traffic_light

    def get_traffic_light_for_position(self, pos):
        return self.crosswalk_to_traffic_light.get(pos, None)

    def shortest_path(self, start, goal, agent_type, dynamic_obstacles=None):
        """Calculate the shortest path from start to goal for the agent type using weighted A*."""
        if start == goal:
            return [start]

        def is_valid(position):
            return not self.is_obstacle(position, agent_type, dynamic_obstacles)

        open_set = []
        heapq.heappush(open_set, (0, start))
        came_from = {}
        g_score = {start: 0}
        f_score = {start: self.heuristic(start, goal)}

        while open_set:
            _, current = heapq.heappop(open_set)

            if current == goal:
                return self.reconstruct_path(came_from, current)

            neighbors = [
                (current[0] + dx, current[1] + dy)
                for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]
            ]

            for neighbor in neighbors:
                if not is_valid(neighbor):
                    continue

                terrain_cost = self.traversal_cost(neighbor, agent_type)
                if terrain_cost == float('inf'):
                    continue  # Skip impassable terrain

                tentative_g_score = g_score[current] + terrain_cost
                if neighbor not in g_score or tentative_g_score < g_score[neighbor]:
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g_score
                    f_score[neighbor] = tentative_g_score + self.heuristic(neighbor, goal)
                    heapq.heappush(open_set, (f_score[neighbor], neighbor))
        return []

    def heuristic(self, a, b):
        """Manhattan distance as heuristic for A*."""
        return abs(a[0] - b[0]) + abs(a[1] - b[1])

    def reconstruct_path(self, came_from, current):
        """Reconstruct the path from the goal to the start."""
        path = []
        while current in came_from:
            path.append(current)
            current = came_from[current]
        path.append(current)
        return path[::-1]

class BaseAgent(ap.Agent):
    def __init__(self, model, initial_position, destination, **kwargs):
        super().__init__(model, **kwargs)
        self.messages = []  # Queue for incoming messages
        self.waiting_for_response = False
        self.initial_position = initial_position
        self.destination = destination
        self.history = [{'posicion': self.initial_position, 'accion': 'Inicio'}]  # Initial position
        print(f"Agent {self.id} initialized at position {self.initial_position}")
        self.environment = self.model.environment
        self.next_position = None
        self.intended_position = None
        self.path = []
        self.steps_taken = 0  # Track steps taken
        self.reached_destination = False  # Track if agent reached destination
        # Initialize alternate route counter
        self.alternate_route_count = 0  # Track alternate routes taken

    def setup_agent(self, agent_type):
        self.agent_type = agent_type
        self.position = self.initial_position
        self.destination = self.destination

    def send_message(self, other_agent, message):
        """Send a message to another agent."""
        other_agent.messages.append((self, message))

    def receive_message(self, other_agent, message):
        """Handle incoming messages."""
        if message.key == 'negotiation_request':
            # Compare IDs to decide who proceeds
            if self.custom_id < other_agent.custom_id:
                # I have priority, respond that I will proceed
                response = Message('negotiation_response', {'from': self, 'to': other_agent, 'action': 'wait'})
            else:
                # I will yield
                response = Message('negotiation_response', {'from': self, 'to': other_agent, 'action': 'proceed'})
            self.send_message(other_agent, response)
        elif message.key == 'negotiation_response':
            # Receive response from other agent
            self.negotiation_outcome = message.content['action']
            self.waiting_for_response = False

    def process_messages(self):
        """Process all incoming messages."""
        while self.messages:
            other_agent, message = self.messages.pop(0)
            self.receive_message(other_agent, message)

    def can_proceed_to_next_position(self):
        """Determine if the agent can proceed to the next position, considering traffic lights."""
        if self.intended_position is None:
            return False
        if self.environment.is_crosswalk(self.intended_position):
            traffic_light = self.environment.get_traffic_light_for_position(self.intended_position)
            if traffic_light is None:
                return True  # No traffic light controlling this crosswalk
            state = traffic_light.current_state
            if self.agent_type == 'pedestrian':
                return state == 'green'
            elif self.agent_type == 'car':
                if state == 'red':
                    return True
                elif state == 'yellow':
                    # Determine if can make it across on time
                    steps_needed = self.steps_to_cross_crosswalk()
                    remaining_yellow_duration = traffic_light.state_durations[traffic_light.current_state_index] - traffic_light.time_in_state
                    return remaining_yellow_duration >= steps_needed
                else:  # Green
                    return False
        else:
            return True  # Not a crosswalk, can proceed

    def steps_to_cross_crosswalk(self):
        """Calculate the number of steps needed to cross the crosswalk starting from current position."""
        steps = 0
        for pos in self.path[1:]:
            if self.environment.is_crosswalk(pos):
                steps += 1
            else:
                break
        return steps if steps > 0 else 1  # At least 1 step needed

    def intent(self):
        """Declare the intended next position, possibly initiating negotiation."""
        if self.position == self.destination:
            self.history.append({'posicion': self.position, 'accion': 'Llego al destino'})
            self.position = None  # Remove agent from the grid
            self.reached_destination = True  # Mark as reached destination
            return

        # Recalculate the path from current position
        self.path = self.environment.shortest_path(self.position, self.destination, self.agent_type)
        if not self.path or len(self.path) < 2:
            self.history.append({'posicion': self.position, 'accion': 'Esperando (Bloqueado)'})
            self.next_position = self.position
            return

        # Determine the next step from the path
        self.intended_position = self.path[1]

        # Check for traffic lights
        if not self.can_proceed_to_next_position():
            # Cannot proceed due to traffic light, wait
            self.intended_position = self.position  # Wait in place
            self.next_position = self.position
            self.history.append({'posicion': self.position, 'accion': 'Esperando (Semaforo)'})
            return

        # Proceed with collision detection
        other_agents_intents = {agent.intended_position: agent for agent in self.model.peatones + self.model.conductores
                                if agent != self and agent.intended_position is not None}

        if self.intended_position in other_agents_intents:
            # Intended position conflicts with another agent's intended position
            conflicting_agent = other_agents_intents[self.intended_position]
            # Send negotiation message
            message = Message('negotiation_request', {'from': self, 'to': conflicting_agent})
            self.send_message(conflicting_agent, message)
            # Mark that we need to wait for negotiation
            self.waiting_for_response = True
            self.history.append({'posicion': self.position, 'accion': 'Esperando (Negociacion)'})
        else:
            # Intended position is free, proceed
            self.next_position = self.intended_position

    def execute_move(self):
        """Execute the movement based on the negotiation outcome."""
        if self.position is None:
            return  # Agent has reached destination

        if self.waiting_for_response:
            # Cannot move until negotiation is resolved
            self.history.append({'posicion': self.position, 'accion': 'Esperando (Negociacion)'})
            return

        if hasattr(self, 'negotiation_outcome'):
            if self.negotiation_outcome == 'proceed':
                # Other agent yields, we can move
                self.next_position = self.intended_position
                del self.negotiation_outcome
            else:
                # We have to wait
                self.next_position = self.position
                del self.negotiation_outcome

        if self.next_position and self.next_position != self.position:
            # Move to the next position
            self.position = self.next_position
            self.steps_taken += 1  # Increment steps taken
            if self.path and self.path[1] == self.position:
                self.path.pop(0)
            action = 'Moviendo'
            self.history.append({'posicion': self.position, 'accion': action})
        else:
            # No movement, wait
            self.history.append({'posicion': self.position, 'accion': 'Esperando'})

        # Reset next_position and intended_position for the next step
        self.next_position = None
        self.intended_position = None
        self.waiting_for_response = False

    def move(self):
        """Define the movement behavior."""
        self.intent()

class PeatonAgent(BaseAgent):
    def __init__(self, model, initial_position, destination, **kwargs):
        super().__init__(model, initial_position, destination, **kwargs)
        self.setup_agent(agent_type='pedestrian')

    def intent(self):
        """Override to implement dynamic pathfinding with dynamic obstacles."""
        if self.position == self.destination:
            self.history.append({'posicion': self.position, 'accion': 'Llego al destino'})
            self.position = None  # Remove agent from the grid
            self.reached_destination = True  # Mark as reached destination
            return

        # Collect dynamic obstacles (positions of other agents)
        other_agents_positions = {agent.position for agent in self.model.peatones + self.model.conductores
                                  if agent != self and agent.position is not None}
        other_agents_intents = {agent.intended_position for agent in self.model.peatones + self.model.conductores
                                if agent != self and agent.intended_position is not None}

        dynamic_obstacles = other_agents_positions.union(other_agents_intents)

        # Store previous path before recalculating
        previous_path = self.path.copy() if self.path else None

        # Recalculate the path from current position considering dynamic obstacles
        self.path = self.environment.shortest_path(self.position, self.destination, self.agent_type, dynamic_obstacles)
        if not self.path or len(self.path) < 2:
            self.history.append({'posicion': self.position, 'accion': 'Esperando (Bloqueado)'})
            self.next_position = self.position
            return

        # Check if the path has changed
        if previous_path and self.path != previous_path:
            self.alternate_route_count += 1  # Increment alternate route counter

        # Determine the next step from the path
        self.intended_position = self.path[1]

        # Check for traffic lights
        if not self.can_proceed_to_next_position():
            # Cannot proceed due to traffic light, wait
            self.intended_position = self.position  # Wait in place
            self.next_position = self.position
            self.history.append({'posicion': self.position, 'accion': 'Esperando (Semaforo)'})
            return

        # Proceed with collision detection
        conflicting_agents = [agent for agent in self.model.peatones + self.model.conductores
                              if agent != self and agent.intended_position == self.intended_position]

        if conflicting_agents:
            # Intended position conflicts with another agent's intended position
            conflicting_agent = conflicting_agents[0]  # Assuming one conflicting agent for simplicity
            # Send negotiation message
            message = Message('negotiation_request', {'from': self, 'to': conflicting_agent})
            self.send_message(conflicting_agent, message)
            # Mark that we need to wait for negotiation
            self.waiting_for_response = True
            self.history.append({'posicion': self.position, 'accion': 'Esperando (Negociacion)'})
        else:
            # Intended position is free, proceed
            self.next_position = self.intended_position

class ConductorAgent(BaseAgent):
    def __init__(self, model, initial_position, destination, **kwargs):
        super().__init__(model, initial_position, destination, **kwargs)
        self.setup_agent(agent_type='car')
        self.crossed_first_light = False  # Flag to track if the first traffic light has been crossed

    def intent(self):
        """Use the base intent method without dynamic pathfinding."""
        super().intent()

    def can_proceed_to_next_position(self):
        """Override to make cars ignore the second traffic light once the first is crossed."""
        if self.crossed_first_light:
            return True  # Ignore traffic lights after crossing the first one
        else:
            # Use BaseAgent's method to check traffic lights
            can_proceed = super().can_proceed_to_next_position()
            # If the car is about to move into a traffic light-controlled crosswalk and can proceed, set the flag
            if can_proceed and self.environment.is_crosswalk(self.intended_position):
                traffic_light = self.environment.get_traffic_light_for_position(self.intended_position)
                if traffic_light is not None:
                    self.crossed_first_light = True
            return can_proceed

class TrafficModel(ap.Model):
    def setup(self):
        self.grid = self.p['environment_grid']
        self.environment = Environment(self.grid)

        # Create traffic light groups with opposite initial states
        self.vertical_traffic_light = TrafficLightGroup(
            self,
            'vertical',
            positions=[(8,9), (11,10)],
            initial_state_index=0  # Starts at 'red'
        )
        self.horizontal_traffic_light = TrafficLightGroup(
            self,
            'horizontal',
            positions=[(10,8), (9,11)],
            initial_state_index=2  # Starts at 'green'
        )

        # Assign traffic lights to crosswalks in the environment
        self.environment.assign_traffic_lights_to_crosswalks(self.horizontal_traffic_light, self.vertical_traffic_light)

        self.traffic_lights = [self.horizontal_traffic_light, self.vertical_traffic_light]

        # Initialize pedestrians
        self.peatones = []
        for idx in range(len(self.p['initial_position_peaton'])):
            initial_position = self.p['initial_position_peaton'][idx]
            destination = self.p['destination_peaton'][idx]
            peaton = PeatonAgent(self, initial_position=initial_position, destination=destination)
            self.peatones.append(peaton)

        # Initialize cars
        self.conductores = []
        for idx in range(len(self.p['initial_position_conductor'])):
            initial_position = self.p['initial_position_conductor'][idx]
            destination = self.p['destination_conductor'][idx]
            conductor = ConductorAgent(self, initial_position=initial_position, destination=destination)
            self.conductores.append(conductor)

        # Initialize occupied positions
        self.occupied_positions = set()
        for agent in self.peatones + self.conductores:
            if agent.position is not None:
                if agent.position in self.occupied_positions:
                    print(f"Warning: Position {agent.position} is already occupied!")
                self.occupied_positions.add(agent.position)

        self.max_steps = 1000
        self.current_step = 0

        # Initialize data collection for JSON output
        self.steps_data = []  # List to store step-by-step data
        self.manifest = []

        # Initialize alternate route count
        self.total_alternate_routes = 0

        # Build manifest with separate counts for pedestrians and cars
        unique_id = 0

        # Process Peatones
        for peaton in self.peatones:
            initial_pos = peaton.initial_position
            destination_pos = peaton.destination
            horizontal = initial_pos[1] != destination_pos[1]  # True if moving horizontally

            # Assign a unique ID
            peaton.custom_id = unique_id
            unique_id += 1

            self.manifest.append({
                'id': peaton.custom_id,
                'model': 'pedestrian',
                'horizontal': horizontal,
                'spawn_location': list(initial_pos),
                'destination': list(destination_pos)
            })

        # Process Conductores
        for idx, conductor in enumerate(self.conductores, 1):
            initial_pos = conductor.initial_position
            destination_pos = conductor.destination
            horizontal = initial_pos[1] != destination_pos[1]  # True if moving horizontally

            # Assign a unique ID
            conductor.custom_id = unique_id
            unique_id += 1

            # Assign model name
            model_name = f"car{idx}" if idx <= 4 else f"car{idx % 4 + 1}"

            self.manifest.append({
                'id': conductor.custom_id,
                'model': model_name,
                'horizontal': horizontal,
                'spawn_location': list(initial_pos),
                'destination': list(destination_pos)
            })

        # Process Traffic Lights
        for traffic_light in self.traffic_lights:
            # Assign a unique ID
            traffic_light.custom_id = unique_id
            unique_id += 1

            self.manifest.append({
                'id': traffic_light.custom_id,
                'model': 'traffic_light',
                'group_name': traffic_light.group_name,
                'positions': [list(pos) for pos in traffic_light.positions],
                'spawn_location': None  # Traffic lights don't have a spawn location
            })

        print("Manifest:")
        for agent in self.peatones + self.conductores + self.traffic_lights:
            manifest_entry = next((item for item in self.manifest if item['id'] == agent.custom_id), None)
            if manifest_entry:
                if manifest_entry['model'] == 'traffic_light':
                    print(f"ID: {manifest_entry['id']}, Model: {manifest_entry['model']}, Group: {manifest_entry['group_name']}")
                else:
                    print(f"ID: {manifest_entry['id']}, Model: {manifest_entry['model']}, Horizontal: {manifest_entry.get('horizontal', 'N/A')}")
            else:
                print(f"ID: {agent.custom_id} not found in manifest.")

    def step(self):
        if self.current_step >= self.max_steps:
            self.running = False
            return

        # Update traffic lights
        for traffic_light in self.traffic_lights:
            traffic_light.step()

        # Record traffic light states
        current_light_states = []
        for tl in self.traffic_lights:
            current_light_states.append({
                'id': tl.custom_id,
                'group_name': tl.group_name,
                'positions': [list(pos) for pos in tl.positions],
                'state': tl.current_state
            })

        # Agents declare their intents
        for agent in self.peatones + self.conductores:
            if agent.position:
                agent.intent()

        # Agents process messages
        for agent in self.peatones + self.conductores:
            if agent.position:
                agent.process_messages()

        # Agents execute their moves
        self.occupied_positions = set()
        for agent in self.peatones + self.conductores:
            if agent.position:
                agent.execute_move()
                if agent.position:
                    self.occupied_positions.add(agent.position)

        # Collect positions and actions for JSON output
        step_agents = []
        for agent in self.peatones + self.conductores:
            if agent.position is not None:
                pos = {'id': agent.custom_id, 'pos': [agent.position[0], agent.position[1]]}
                # Include the action
                action = agent.history[-1]['accion'] if agent.history else 'Unknown'
                pos['action'] = action
                step_agents.append(pos)
            else:
                # Do not include agents that have reached their destination
                continue

        # Collect traffic lights' states
        step_traffic_lights = current_light_states

        # Combine into a single step record
        step_record = {
            'step_number': self.current_step + 1,
            'agents': step_agents,
            'traffic_lights': step_traffic_lights
        }

        self.steps_data.append(step_record)

        # Update total alternate routes taken
        self.total_alternate_routes = sum(peaton.alternate_route_count for peaton in self.peatones)

        # Determine if the model should continue running
        self.running = any(
            peaton.position is not None for peaton in self.peatones
        ) or any(
            conductor.position is not None for conductor in self.conductores
        )

        self.current_step += 1
        print(f"Completed: {self.current_step} steps", end='\r')

    def end(self):
        print("\n--- Resumen de movimientos ---")
        for i, peaton in enumerate(self.peatones, 1):
            print(f"\nHistorial de movimientos del pedestrian {i}:")
            for entry in peaton.history:
                print(f"Posicion: {entry['posicion']}, Accion: {entry.get('accion', 'movimiento')}")
        for i, conductor in enumerate(self.conductores, 1):
            print(f"\nHistorial de movimientos del conductor {i}:")
            for entry in conductor.history:
                print(f"Posicion: {entry['posicion']}, Accion: {entry.get('accion', 'movimiento')}")

        self.write_json_output()
        self.output_statistics()  # Output the required statistics

    def write_json_output(self):
        """Write the collected simulation data to a JSON file."""
        output_data = {
            'metadata': {
                'cars': len(self.conductores),
                'pedestrians': len(self.peatones),
                'traffic_lights': len(self.traffic_lights),
                'obstacles': len(self.environment.obstacles),
                'steps': len(self.steps_data)
            },
            'manifest': self.manifest,
            'steps': self.steps_data
        }
        # Save to a file
        with open('data.json', 'w') as json_file:
            json.dump(output_data, json_file, indent=4)
        print("\nSimulation data has been written to 'data.json'.")

    def output_statistics(self):
        """Calculate and print the required statistics."""
        print("\n--- Metricas de la Simulacion ---")

        # Pedestrians
        total_pedestrian_steps = 0
        total_pedestrian_alternate_routes = 0
        pedestrian_count = len(self.peatones)
        pedestrians_reached = 0
        print("\nAgentes Peatones:")
        for peaton in self.peatones:
            steps = peaton.steps_taken
            alternate_routes = peaton.alternate_route_count
            reached = peaton.reached_destination
            total_pedestrian_steps += steps
            total_pedestrian_alternate_routes += alternate_routes
            if reached:
                pedestrians_reached += 1
            status = "- Llego a su destino" if reached else "- No llego a su destino"
            print(f"ID del agente {peaton.custom_id}: Pasos tomados = {steps}, Rutas alternas tomadas = {alternate_routes}, {status}")
        avg_pedestrian_steps = total_pedestrian_steps / pedestrian_count if pedestrian_count > 0 else 0
        avg_pedestrian_alternate_routes = total_pedestrian_alternate_routes / pedestrian_count if pedestrian_count > 0 else 0
        print(f"Total de rutas alternas tomadas por peatones: {total_pedestrian_alternate_routes}")
        print(f"Promedio de pasos tomados por peatones: {avg_pedestrian_steps:.2f}")
        print(f"Promedio de rutas alternas tomadas por peatones: {avg_pedestrian_alternate_routes:.2f}")
        print(f"Peatones que llegaron a su destino: {pedestrians_reached} de {pedestrian_count}")

        # Cars
        total_car_steps = 0
        car_count = len(self.conductores)
        cars_reached = 0
        print("\nAgentes Conductores:")
        for conductor in self.conductores:
            steps = conductor.steps_taken
            reached = conductor.reached_destination
            total_car_steps += steps
            if reached:
                cars_reached += 1
            status = "- Llego a su destino" if reached else "- No llego a su destino"
            print(f"ID del agente {conductor.custom_id}: Pasos tomados = {steps}, {status}")
        avg_car_steps = total_car_steps / car_count if car_count > 0 else 0
        print(f"Promedio de pasos tomados por conductores: {avg_car_steps:.2f}")
        print(f"Conductores que llegaron a su destino: {cars_reached} de {car_count}")

        # Total Alternate Routes
        print(f"\nTotal de rutas alternas tomadas por agentes: {total_pedestrian_alternate_routes}")

# Define the animate_simulation function (No changes required here)
def animate_simulation(model):
    # Create a mapping from agent IDs to labels and colors
    agent_labels = {}
    agent_colors = {}

    # Assign labels and colors based on the manifest
    for manifest_entry in model.manifest:
        agent_id = manifest_entry['id']
        agent_model = manifest_entry['model']
        if agent_model == 'pedestrian':
            agent_labels[agent_id] = f"Pedestrian {agent_id}"
            agent_colors[agent_id] = 'blue'
        elif agent_model.startswith('car'):
            agent_labels[agent_id] = f"Car {agent_id}"
            agent_colors[agent_id] = 'red'
        else:
            continue  # Skip traffic lights for agent labels

    # Environment setup
    grid_size = model.environment.height
    environment = model.environment
    obstacles = environment.obstacles
    crosswalks = environment.crosswalks
    road = environment.road
    sidewalks = environment.sidewalks

    # Retrieve traffic light states
    traffic_light_states = model.steps_data  # Each step includes traffic lights
    traffic_light_groups = {tl.group_name: tl.positions for tl in model.traffic_lights}

    fig, ax = plt.subplots(figsize=(8, 8))
    num_steps = len(model.steps_data)

    def update(frame):
        ax.clear()

        # Configuration of the grid with extent for proper alignment
        grid = np.zeros((grid_size, grid_size))
        for pos in road:
            grid[pos] = 0.3  # Road
        for obs in obstacles:
            grid[obs] = -1  # Obstacle
        for cw in crosswalks:
            grid[cw] = 0.7  # Crosswalk
        for sw in sidewalks:
            grid[sw] = 0.5  # Sidewalk

        # Display the grid
        ax.imshow(grid, cmap='gray_r', vmin=-1, vmax=1, extent=[-0.5, grid_size - 0.5, grid_size - 0.5, -0.5])

        # Draw the sidewalks
        if frame == 0:
            ax.scatter([], [], c='green', marker='s', s=100, label='Sidewalk')
            ax.scatter([], [], c='gray', marker='s', s=100, label='Road')
            ax.scatter([], [], c='yellow', marker='s', s=100, label='Crosswalk')

        # Draw the traffic lights based on recorded states
        if frame < num_steps:
            current_light_states = traffic_light_states[frame]['traffic_lights']
        else:
            current_light_states = traffic_light_states[-1]['traffic_lights']  # Use the last state if out of range

        for tl_state in current_light_states:
            positions = tl_state['positions']
            state = tl_state['state']
            group_name = tl_state['group_name']
            for pos in positions:
                color = state
                ax.scatter(pos[1], pos[0], c=color, marker='o', s=300, edgecolors='black', zorder=5)
                # Labels to traffic lights
                ax.text(pos[1] + 0.3, pos[0], group_name.capitalize(), fontsize=9, ha='left', va='center')

        # Draw the agents
        if frame < num_steps:
            current_agents = traffic_light_states[frame]['agents']
            for agent in current_agents:
                agent_id = agent['id']
                pos_x, pos_y = agent['pos'][1], agent['pos'][0]
                color = agent_colors.get(agent_id, 'black')
                # Only include label if frame == 0 and not already used
                if frame == 0 and agent_id in agent_labels:
                    label = agent_labels.pop(agent_id)
                else:
                    label = ""
                ax.scatter(pos_x, pos_y, c=color, s=200, marker='o', edgecolors='black', zorder=6, label=label)
        else:
            current_agents = traffic_light_states[-1]['agents']
            for agent in current_agents:
                agent_id = agent['id']
                pos_x, pos_y = agent['pos'][1], agent['pos'][0]
                color = agent_colors.get(agent_id, 'black')
                label = ""
                ax.scatter(pos_x, pos_y, c=color, s=200, marker='o', edgecolors='black', zorder=6, label=label)

        ax.set_title(f"Simulation Step: {frame + 1}")
        ax.set_xticks(range(grid_size))
        ax.set_yticks(range(grid_size))
        ax.set_xlim(-0.5, grid_size - 0.5)
        ax.set_ylim(grid_size - 0.5, -0.5)  # Invert y-axis to match grid origin
        ax.grid(True)

    ani = anim_module.FuncAnimation(fig, update, frames=num_steps, repeat=False, interval=500)
    plt.close(fig)
    return ani

# Parameters remain the same
params = {
    'environment_grid': [
      [3, 3, 3, 3, 3, 3, 1, 1, 3, 0, 0, 1, 3, 3, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 3, 1, 1, 0, 0, 1, 1, 3, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 3, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 3, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 3, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 3, 1, 1, 3, 3, 3, 3, 3, 3],
      [1, 1, 3, 1, 3, 1, 3, 1, 1, 0, 0, 1, 1, 1, 1, 3, 1, 3, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [3, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 3],
      [0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0],
      [1, 3, 1, 3, 1, 1, 1, 1, 1, 2, 2, 3, 1, 1, 1, 1, 1, 3, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 3, 1, 1, 1, 0, 0, 1, 1, 1, 1, 3, 1, 1, 1, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 3, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 3, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 3, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 3, 1, 1, 0, 0, 3, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 3, 1, 3, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 3, 1, 1, 0, 0, 1, 1, 3, 3, 3, 3, 3, 3, 3],
    ],

    'initial_position_peaton': [(12, 1), (18, 6), (1, 12), (0, 6), (6, 19), (19, 13)],
    'destination_peaton': [(12, 19), (0, 7), (19, 12), (6, 0) , (13, 0), (11, 0)],
    'initial_position_conductor': [(0, 9), (19, 10), (10, 0), (9, 19), (10, 1), (9, 18)],
    'destination_conductor': [(9, 0), (10, 19), (19, 9), (0, 10),(10, 19), (9, 0)],

}

# Initialize and run the model
model = TrafficModel(params)
model.run()

# Animation
ani = animate_simulation(model)
display(HTML(ani.to_jshtml()))

#Pocos Obstaculos

params = {
    'environment_grid': [
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 3, 0, 0, 1, 1, 3, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [1, 1, 1, 1, 3, 1, 1, 1, 1, 0, 0, 1, 1, 3, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0],
      [1, 1, 1, 1, 3, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 3, 1, 1, 1, 1],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 3, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 3, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
    ],

    'initial_position_peaton': [(12, 1), (18, 6), (1, 12), (0, 6), (6, 19), (19, 13)],
    'destination_peaton': [(12, 19), (0, 7), (19, 12), (6, 0) , (13, 0), (11, 0)],
    'initial_position_conductor': [(0, 9), (19, 10), (10, 0), (9, 19), (10, 1), (9, 18)],
    'destination_conductor': [(9, 0), (10, 19), (19, 9), (0, 10),(10, 19), (9, 0)],
}


# Initialize and run the model
model = TrafficModel(params)
model.run()

# Animation
ani = animate_simulation(model)
display(HTML(ani.to_jshtml()))

#cantaida media de obstaculos

params = {
    'environment_grid': [
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 3, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 3, 1, 1, 0, 0, 3, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [1, 1, 1, 3, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 3, 1, 1, 1, 3, 1],
      [1, 1, 3, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0],
      [1, 1, 3, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 3, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 3, 1, 1, 1, 0, 0, 1, 1, 1, 1, 3, 1, 1, 1, 1],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 3, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 3, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 3, 1, 1, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
    ],

    'initial_position_peaton': [(12, 1), (18, 6), (1, 12), (0, 6), (6, 19), (19, 13), (8, 0), (13, 19)],
    'destination_peaton': [(12, 19), (0, 7), (19, 12), (6, 0) , (13, 0), (11, 0), (6, 19), (19, 6)],
    'initial_position_conductor': [(0, 9), (19, 10), (10, 0), (9, 19), (10, 1), (9, 18), (-1, 9), (20, 10)],
    'destination_conductor': [(9, 0), (10, 19), (19, 9), (0, 10),(10, 19), (9, 0), (19, 9), (0, 10)],

}


# Initialize and run the model
model = TrafficModel(params)
model.run()

# Animation
ani = animate_simulation(model)
display(HTML(ani.to_jshtml()))

#Muchos obstaculos

params = {
    'environment_grid': [
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 3, 1, 1, 0, 0, 1, 1, 3, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 3, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 3, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 3, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 3, 1, 1, 3, 3, 3, 3, 3, 3],
      [1, 1, 3, 1, 3, 1, 3, 1, 1, 0, 0, 1, 1, 1, 1, 3, 1, 3, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0],
      [1, 3, 1, 3, 1, 1, 1, 1, 1, 2, 2, 3, 1, 1, 1, 1, 1, 3, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 3, 1, 1, 1, 0, 0, 1, 1, 1, 1, 3, 1, 1, 1, 1],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 3, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 3, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 3, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 3, 1, 1, 0, 0, 3, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 3, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
    ],

    'initial_position_peaton': [(12, 1), (18, 6), (13, 0), (0, 6), (6, 19), (19, 12), (8, 0), (13, 19), (0 ,8), (0, 11), (19 , 13), (0, 13)],
    'destination_peaton': [(12, 19), (0, 7), (19, 11), (6, 0) , (13, 0), (11, 0), (6, 19), (19, 6), (0, 13), (19, 8), (8, 0), (19, 13)],
    'initial_position_conductor': [(0, 9), (19, 10), (10, 0), (9, 19), (10, 1), (9, 18), (-1, 9), (20, 10)],
    'destination_conductor': [(9, 0), (10, 19), (19, 9), (0, 10),(10, 19), (9, 0), (19, 9), (0, 10)],

}

# Initialize and run the model
model = TrafficModel(params)
model.run()

# Animation
ani = animate_simulation(model)
display(HTML(ani.to_jshtml()))

#Pocos Obstaculos

params = {
    'environment_grid': [
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 3, 0, 0, 1, 1, 3, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [1, 1, 1, 1, 3, 1, 1, 1, 1, 0, 0, 1, 1, 3, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0],
      [1, 1, 1, 1, 3, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 3, 1, 1, 1, 1],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 3, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 3, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
    ],

    'initial_position_peaton': [(12, 1), (18, 6), (1, 12), (0, 6), (6, 19), (19, 13)],
    'destination_peaton': [(12, 19), (0, 7), (19, 12), (6, 0) , (13, 0), (11, 0)],
    'initial_position_conductor': [(0, 9), (19, 10), (10, 0), (9, 19), (10, 1), (9, 18)],
    'destination_conductor': [(9, 0), (10, 19), (19, 9), (0, 10),(10, 19), (9, 0)],
}

#cantaida media de obstaculos

params = {
    'environment_grid': [
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 3, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 3, 1, 1, 0, 0, 3, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [1, 1, 1, 3, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 3, 1, 1, 1, 3, 1],
      [1, 1, 3, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0],
      [1, 1, 3, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 3, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 3, 1, 1, 1, 0, 0, 1, 1, 1, 1, 3, 1, 1, 1, 1],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 3, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 3, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 3, 1, 1, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
    ],

    'initial_position_peaton': [(12, 1), (18, 6), (1, 12), (0, 6), (6, 19), (19, 13), (8, 0), (13, 19)],
    'destination_peaton': [(12, 19), (0, 7), (19, 12), (6, 0) , (13, 0), (11, 0), (6, 19), (19, 6)],
    'initial_position_conductor': [(0, 9), (19, 10), (10, 0), (9, 19), (10, 1), (9, 18), (-1, 9), (20, 10)],
    'destination_conductor': [(9, 0), (10, 19), (19, 9), (0, 10),(10, 19), (9, 0), (19, 9), (0, 10)],

}


#Muchos obstaculos

params = {
    'environment_grid': [
      [3, 3, 3, 3, 3, 3, 1, 1, 3, 0, 0, 1, 3, 3, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 3, 1, 1, 0, 0, 1, 1, 3, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 3, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 3, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 3, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 3, 1, 1, 3, 3, 3, 3, 3, 3],
      [1, 1, 3, 1, 3, 1, 3, 1, 1, 0, 0, 1, 1, 1, 1, 3, 1, 3, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [3, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 3],
      [0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0],
      [1, 3, 1, 3, 1, 1, 1, 1, 1, 2, 2, 3, 1, 1, 1, 1, 1, 3, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 3, 1, 1, 1, 0, 0, 1, 1, 1, 1, 3, 1, 1, 1, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 1, 1, 3, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 3, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 1, 1, 1, 0, 0, 3, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 3, 1, 1, 0, 0, 3, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 3, 1, 3, 0, 0, 1, 1, 1, 3, 3, 3, 3, 3, 3],
      [3, 3, 3, 3, 3, 3, 3, 1, 1, 0, 0, 1, 1, 3, 3, 3, 3, 3, 3, 3],
    ],

    'initial_position_peaton': [(12, 1), (18, 6), (13, 0), (0, 6), (6, 19), (19, 12), (8, 0), (13, 19), (0 ,8), (0, 11), (19 , 13), (0, 13)],
    'destination_peaton': [(12, 19), (0, 7), (19, 11), (6, 0) , (13, 0), (11, 0), (6, 19), (19, 6), (0, 13), (19, 8), (8, 0), (19, 13)],
    'initial_position_conductor': [(0, 9), (19, 10), (10, 0), (9, 19), (10, 1), (9, 18), (-1, 9), (20, 10)],
    'destination_conductor': [(9, 0), (10, 19), (19, 9), (0, 10),(10, 19), (9, 0), (19, 9), (0, 10)],

}